<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI & Handwriting Signature Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .variant-card {
            transition: all 0.3s ease-in-out;
        }
        .variant-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .drawing-canvas {
            touch-action: none;
            cursor: crosshair;
        }
    </style>
</head>
<body class="bg-slate-100">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useCallback, useEffect, useRef } = React;

        // --- Signature Canvas Component with Calligraphic Brush ---
        const SignatureCanvas = () => {
            const canvasRef = useRef(null);
            const contextRef = useRef(null);
            const [isDrawing, setIsDrawing] = useState(false);
            const [penColor, setPenColor] = useState("#000000");
            const [baseWidth, setBaseWidth] = useState(3);
            
            // Refs to store previous point data for velocity calculation
            const lastPointRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ratio = Math.max(window.devicePixelRatio || 1, 1);
                canvas.width = canvas.offsetWidth * ratio;
                canvas.height = canvas.offsetHeight * ratio;
                
                const context = canvas.getContext("2d");
                context.scale(ratio, ratio);
                context.lineCap = "round";
                context.lineJoin = "round";
                contextRef.current = context;
            }, []);

            useEffect(() => {
                if(contextRef.current){
                    contextRef.current.strokeStyle = penColor;
                }
            }, [penColor]);
            
            const getCoords = (event) => {
                const rect = canvasRef.current.getBoundingClientRect();
                if (event.touches && event.touches.length > 0) {
                     return { x: event.touches[0].clientX - rect.left, y: event.touches[0].clientY - rect.top };
                }
                return { x: event.nativeEvent.offsetX, y: event.nativeEvent.offsetY };
            }

            const startDrawing = (event) => {
                const { x, y } = getCoords(event);
                setIsDrawing(true);
                lastPointRef.current = { x, y, time: Date.now() };
                
                // Start with a dot
                contextRef.current.lineWidth = baseWidth;
                contextRef.current.beginPath();
                contextRef.current.moveTo(x, y);
                contextRef.current.lineTo(x, y);
                contextRef.current.stroke();
            };

            const stopDrawing = () => {
                setIsDrawing(false);
                lastPointRef.current = null;
            };

            const draw = (event) => {
                if (!isDrawing || !lastPointRef.current) return;

                const { x, y } = getCoords(event);
                const currentTime = Date.now();
                const lastPoint = lastPointRef.current;

                const timeDelta = currentTime - lastPoint.time;
                const distance = Math.sqrt(Math.pow(x - lastPoint.x, 2) + Math.pow(y - lastPoint.y, 2));

                // Velocity calculation (pixels per millisecond)
                const velocity = timeDelta > 0 ? distance / timeDelta : 0;

                // --- Calligraphic Logic ---
                // Inversely map velocity to line width. Faster -> thinner.
                const minWidth = baseWidth * 0.5;
                const maxWidth = baseWidth * 2;
                const sensitivity = 5; // Adjust this factor for more/less variation
                let newWidth = Math.max(maxWidth - (velocity * sensitivity), minWidth);

                contextRef.current.lineWidth = newWidth;
                contextRef.current.beginPath();
                contextRef.current.moveTo(lastPoint.x, lastPoint.y);
                contextRef.current.lineTo(x, y);
                contextRef.current.stroke();

                lastPointRef.current = { x, y, time: currentTime };
            };

            const clearCanvas = () => {
                const canvas = canvasRef.current;
                const context = contextRef.current;
                const ratio = Math.max(window.devicePixelRatio || 1, 1);
                context.clearRect(0, 0, canvas.width / ratio, canvas.height / ratio);
            };

            const downloadSignature = () => {
                const canvas = canvasRef.current;
                const image = canvas.toDataURL("image/png");
                const link = document.createElement('a');
                link.href = image;
                link.download = "my-handwritten-signature.png";
                link.click();
            };
            
            return (
                <div className="bg-white p-6 rounded-xl shadow-sm">
                    <h2 className="text-2xl font-bold text-slate-800 mb-4">Draw Your Own Signature</h2>
                    <div className="flex flex-col md:flex-row gap-4 mb-4 items-center">
                        <div>
                            <label htmlFor="penColor" className="block text-sm font-medium text-slate-600">Color:</label>
                            <input type="color" id="penColor" value={penColor} onChange={(e) => setPenColor(e.target.value)} className="w-12 h-10 p-1 border border-slate-300 rounded-md"/>
                        </div>
                        <div className="flex-grow">
                            <label htmlFor="penWidth" className="block text-sm font-medium text-slate-600">Base Width: {baseWidth}</label>
                            <input type="range" id="penWidth" min="1" max="10" value={baseWidth} onChange={(e) => setBaseWidth(e.target.value)} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer"/>
                        </div>
                    </div>
                    <canvas
                        ref={canvasRef}
                        className="drawing-canvas bg-white border-2 border-dashed border-slate-300 rounded-lg w-full h-64"
                        onMouseDown={startDrawing}
                        onMouseUp={stopDrawing}
                        onMouseLeave={stopDrawing}
                        onMouseMove={draw}
                        onTouchStart={startDrawing}
                        onTouchEnd={stopDrawing}
                        onTouchMove={draw}
                    />
                    <div className="flex gap-4 mt-4">
                        <button onClick={clearCanvas} className="w-full flex-1 bg-amber-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-amber-600 transition">Clear</button>
                        <button onClick={downloadSignature} className="w-full flex-1 bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition">Download</button>
                    </div>
                </div>
            );
        };
        
        // --- AI Signature Component ---
        const AISignatureGenerator = () => {
            const [name, setName] = useState('R');
            const [allGeneratedImages, setAllGeneratedImages] = useState({});
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);

            const apiKey = "AIzaSyD1l8p5x80069h5RPwPpIs6OuoL87YSYEY";
            
            const signatureStyles = [
                {
                    name: "Elegant Handwritten",
                    prompt: (name) => `A beautiful, elegant, and realistic handwritten signature for the name "${name}". The style should be flowing and cursive, with sophisticated, natural-looking flourishes and ligatures, like a real-life signature from a professional. The signature must be legible and look authentic. Rendered in fine black ink on a clean white background.`
                },
                {
                    name: "Classic Script",
                    prompt: (name) => `An elegant and classic signature for the name "${name}". The style features beautiful, flowing, cursive script with sophisticated, traditional flourishes. The signature should look timeless, legible, and highly professional, suitable for signing official documents. Rendered in fine black ink on a clean white background.`
                },
                {
                    name: "Dynamic Calligraphy",
                    prompt: (name) => `A masterpiece of modern, artistic calligraphy, creating a signature for the name "${name}". The style must precisely replicate a specific aesthetic: the signature features a large, elegant, rounded capital letter as the central element. A second, smaller loop gracefully extends from the bottom left of the main letter. A single, razor-sharp diagonal line strikes through the composition. From the top right of the main letter, a long, sweeping flourish extends outwards, ending in a graceful curve. A crucial and non-negotiable detail is a small, tight, zig-zag scribble pattern on the line connecting the main letter to its top-right flourish. The signature must be rendered in bold black ink on a pristine white background, capturing a professional, artistic flair and dynamic movement. This is a unique piece of graphic art, not a standard font.`
                },
                {
                    name: "Minimalist Line",
                    prompt: (name) => `A chic, minimalist signature for the name "${name}", created using a single, continuous, and fluid line where possible. The design is clean, understated, and modern, avoiding excessive flourishes. It should be a simple yet stylish representation of the name. Rendered in a clean black line on a plain white background.`
                }
            ];
            
            const generateAllVariants = useCallback(async () => {
                 if (!name.trim()) {
                    setError("Please enter a name or initials.");
                    return;
                }
                setIsLoading(true);
                setError(null);
                setAllGeneratedImages({});

                const newImages = {};
                let overallError = null;

                for (const style of signatureStyles) {
                    try {
                        const prompt = style.prompt(name);
                        const payload = { instances: [{ prompt: prompt }], parameters: { "sampleCount": 3 } };
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            let errorDetail = `HTTP error! Status: ${response.status}`;
                            try { const errorBody = await response.json(); if (errorBody.error && errorBody.error.message) { errorDetail = errorBody.error.message; } } catch (e) {}
                            throw new Error(errorDetail);
                        }

                        const result = await response.json();

                        if (result.predictions && result.predictions.length > 0) {
                            const imageUrls = result.predictions.map(pred => `data:image/png;base64,${pred.bytesBase64Encoded}`);
                            newImages[style.name] = imageUrls;
                            setAllGeneratedImages({ ...newImages });
                        } else {
                            throw new Error('No predictions returned from the API.');
                        }
                    } catch (err) {
                        console.error(`Failed to generate signature for: ${style.name}`, err);
                        if (!overallError) { overallError = err.message; }
                    }
                }

                 if (overallError) {
                    if (overallError.includes("suspended")) { setError(`Error: Your API key has been suspended by Google. Please generate a new key.`); }
                    else if (overallError.includes("billed users")) { setError(`Error: This AI model requires a billing account to be enabled for your Google Cloud project.`); }
                    else { setError(`Generation Error: "${overallError}". Please check your API key and try again.`); }
                }
                setIsLoading(false);
            }, [name]);

            useEffect(() => { generateAllVariants(); }, []);

            const handleDownload = useCallback((imageUrl, styleName, index) => {
                if (!imageUrl) return;
                const link = document.createElement('a');
                const safeName = name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const safeStyle = styleName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                link.download = `ai-signature-${safeName}-${safeStyle}-variant-${index + 1}.png`;
                link.href = imageUrl;
                link.click();
            }, [name]);

            return (
                <div className="bg-white p-6 rounded-xl shadow-sm">
                    <h2 className="text-2xl font-bold text-slate-800 mb-4">Generate a Signature with AI</h2>
                    <div className="space-y-6">
                        <div>
                           <h3 className="text-lg font-semibold text-slate-700 mb-2">
                                <span className="bg-blue-600 text-white rounded-full w-7 h-7 inline-flex items-center justify-center mr-3">1</span>
                                Enter Your Name & Regenerate
                           </h3>
                            <div className="flex flex-col sm:flex-row gap-4">
                                <input
                                    type="text"
                                    value={name}
                                    onChange={(e) => setName(e.target.value)}
                                    placeholder="Enter name or initials"
                                    className="w-full sm:w-1/3 px-4 py-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 transition"
                                />
                                <button
                                    onClick={generateAllVariants}
                                    disabled={isLoading}
                                    className="w-full sm:w-auto flex-grow flex items-center justify-center gap-3 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="feather feather-refresh-cw"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                                    {isLoading ? 'Creating...' : 'Regenerate Variants'}
                                </button>
                            </div>
                        </div>
                        <div className="flex-grow flex items-center justify-center bg-slate-50 border-2 border-dashed border-slate-300 rounded-xl p-5 min-h-[400px]">
                            {isLoading && Object.keys(allGeneratedImages).length === 0 && (
                                <div className="text-slate-500 text-center">Generating styles...</div>
                            )}
                            {error && <div className="text-red-500 text-center p-4">{error}</div>}
                            {Object.keys(allGeneratedImages).length > 0 && (
                                <div className="w-full space-y-8">
                                    {signatureStyles.map(style => (
                                        (allGeneratedImages[style.name] && allGeneratedImages[style.name].length > 0) && (
                                        <div key={style.name}>
                                            <h3 className="text-xl font-bold text-slate-800 border-b-2 border-slate-200 pb-2 mb-4">{style.name}</h3>
                                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                                {(allGeneratedImages[style.name] || []).map((imgSrc, index) => (
                                                    <div key={index} className="variant-card flex flex-col items-center p-3 bg-white rounded-lg shadow-md">
                                                        <div className="w-full h-40 flex items-center justify-center mb-3">
                                                            <img src={imgSrc} alt={`AI signature for ${style.name}`} className="max-w-full max-h-full object-contain" />
                                                        </div>
                                                        <button onClick={() => handleDownload(imgSrc, style.name, index)} className="w-full bg-green-600 text-white font-semibold py-2 px-3 rounded-md hover:bg-green-700">Download</button>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                        )
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };
        
        // --- Main App Component ---
        function App() {
            return (
                <div className="min-h-screen bg-slate-100 p-4 lg:p-8">
                    <main className="w-full max-w-7xl mx-auto space-y-8">
                        <div className="text-center">
                            <h1 className="text-4xl md:text-5xl font-bold text-slate-800 tracking-tight">Signature Generator</h1>
                            <p className="mt-2 text-lg text-slate-600">Create your signature by hand or with AI.</p>
                        </div>
                        
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                           <SignatureCanvas />
                           <AISignatureGenerator />
                        </div>
                        
                        <footer className="text-center text-sm text-slate-500 mt-4">
                            <p>Powered by Vahe's</p>
                        </footer>
                    </main>
                </div>
            );
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
